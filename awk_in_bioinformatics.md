# awk简单介绍
对于一个文本文件，linux上的读取方式有很多，代表性的是vim。

而awk也是可以用于文本文件的读取，但是与vim不同。它的处理逻辑是把**每一行当做一个记录**。每一个**记录**中的字段又会根据字段分隔符把字段分割成多个域(fields)。

awk会对每一个记录进行一定的操作（这个部分由用户输入的命令决定）。

在每一个记录里面，每一个fields，也会有一个变量名（从0到n，$n）也是用户处理与调用的最小的一个单位结构。

其中，默认的记录分隔符是 **换行符**；而域的分割符是**空格**。要修改这二者在`awk 'BEGIN{FS="新的域分隔符",RS="新的记录分隔符"}'`。其中`BEGIN{}`表示在一开始会进行的操作。

一个完整的awk的命令的写法是 `'{程序1} {程序2}'`。程序1和程序2表示的是你想对每一个记录所进行的操作。

这样的一个完整的awk语句可以是放在文本（也就是脚本）中的也可以是命令行输入。`{}`包裹的部分会在每一个记录执行。

而在其中还有一类特殊的`{}`，可以再开头和结尾使用：`BEGIN{}`和`END{}`。

此外在`{}`之中可以调用多个函数每一个函数之间的分割用`;`，比如`{print $1;print $2}`。

那么最大的难点自然就是怎么写这样的**程序或者说脚本**。

在awk中可以实现的功能还是较为丰富的，可以实现 定义变量、数字计算以及逻辑判断等。

当然最为重要的是能够找到数据中符合某一个pattern的记录，然后进行一系列的操作。这一点在生信中才是最为重要的操作。 一个简单的例子：`awk '$2 ~ /(GTG)+/ {print $1}' test.txt`。第一个域是DNA序列的名称，第二个域是序列。[更多的awk在NGS中的使用例子](http://userweb.eng.gla.ac.uk/umer.ijaz/bioinformatics/linux.html)

# awk的简单使用以及变量操作
## 引入
这部分，我打算从这样一个fasta文件开始
```
>blah_C1
ACTGTCTGTCACTGTGTTGTGATGTTGTGTGTG
>blah_C2
ACTTTATATATT
>blah_C3
ACTTATATATATATA
>blah_C4
ACTTATATATATATA
>blah_C5
ACTTTATATATT
```
文件名为：`test.fa`
```
Riley Mullen
123 Main Street
Chicago, IL 60601
(312)555-1234

Frank Williams
456 Oak Street
Indianapolis, IN 46201
(317)555-9876

Haley Snell
4231 Elm Street
Detroit, MI 48201
(313)555-4938
```
命名为：`test.txt`

放置在当前使用的目录下。

## 变量与awk

使用awk，很多的场景都是在处理各种各样的数据文件如：fa，bam，bed等。 大多数情况我们希望从其中筛选出一部分符合我们要求的一些序列或者reads。

比如我们想把`test.fa` 改写成![](https://tf-picture-bed-1259792641.cos.ap-beijing.myqcloud.com/blog/2021-09-21-144155.png)这样的一个结构。看着似乎是一个挺简单的变化，但是实现起来却似乎不是那么的容易。

如果用你熟悉的编程语言去实现这个过程你会怎么做呢？

>用python来实现的话固然是可以的，但是在linux里面编写py文件的，emmm你需要配置一个合适的IDE。大佬级别的玩家可以用vim手写，或者直接把vim配置成一个比较好用的IDE（反正我不配，太麻烦了，懒人怎么会去做呢？！！！！！）
>好的，不管这个理由多牵强，在linux里面直接在命令行啪啪啪的写一点代码就可以干的事情，何必创个文件，然后写一堆，然后run it~。这也是为什么`awk`虽然可以支持从脚本读入命令，但是我不想写，因为太麻烦了。
>当然，逻辑过于复杂的处理的话，还是老老实实的用py之类的语言进行，或者用脚本的方式传入`awk`命令。

铛铛铛，先放上一个完整的代码：`awk '{if (/^>/) {gsub(">","",$0);printf $0 "\t";getline;print $0 } }' test.fa`

### 基础变量

之前已经简单介绍了，awk会把每一行当做一个记录，而每一个记录会根据分隔符切分成多个fields。

`cat test.txt`
![](https://tf-picture-bed-1259792641.cos.ap-beijing.myqcloud.com/blog/2021-09-21-145546.png)
可以看到，这里的每一行就是一个记录，第一个记录是`Riley Mullen`。

**awk默认的输入的字段域分隔符是**
- `FS=" "` 空格

也就是会根据空格进行分割。这样这个记录就可以分割成这样两个fields：`Riley`和`Mullen`。

既然有域分割符，那么也就有输入的记录的分隔符。

的确如此，**输入的域分隔符是**

- `RS="\n"` 也就是换行符

当awk读入整个文件的时候见到一个换行符就会切割开来当做一个记录。

那么回到刚刚这个`test.txt`文件。这个文件是一个记录了多个联系方式的文件。可以看到一个记录应该是连续的4行，而一个域应该是这样的连续4行中的1行。但是直接使用`awk`读入很明显会出错，因为识别错了记录。

**因此我们需要对`FS`和`RS`这两个变量进行修改。**

到了这里，我们还没有介绍任何的一个awk的完整命令语句。现在也就会介绍了。

`awk 'BEGIN{print "Hi,This is the biginning."}' test.txt`

![](https://tf-picture-bed-1259792641.cos.ap-beijing.myqcloud.com/blog/2021-09-21-150417.png)

运行结果如上。

诶，为什么只有一段文字，没有`test.txt`里面的内容呢？

`awk`后面跟上`''`的里面便是记录的使用的命令。这样的命令是有`{动作1} {动作2} {动作3}`组成，这些动作也就是会对每一个记录进行的操作。

但是这里的`BEGIN` 是个什么鬼？ 按照刚刚的逻辑来讲，应该会对每一行进行`print "Hi,This is the beginning"`的操作，也就是会在读取每一行的时候都会显示这段文字呀，为什么只会显示一遍呢？

`BEGIN{}`表示，在awk读取文件之前会进行的操作，也就跟写python的时候，一开始`import pandas as pd`一样的操作。 而我在这里并没有写一个普通的`{}`。因此在awk正式读取文件的时候就不会有输出显示。 要有输出显示，我们不急。
>你急的话也可以run一下`awk '{print}' test.txt`，会发现效果和`cat test.txt`是一样的。

有`BEGIN{}`相应的也有`END{}`。

那么在`BEGIN{}`这里，一般进行什么动作呢？嘿嘿当然是：正式读取的时候不能或者不好进行的操作啦~。比如：更改分隔符。
>要是在读取的时候更改分隔符，会发生什么事呢？ 除了第一行，剩下的所有行都会根据这个更改后的分隔符进行分隔啦。

那么现在可以更改我们的分隔符了。回到刚刚的`test.txt`，我们想让记录的分隔符是**空白**，而域的分隔符应该是**换行符**。那么就可以这样写`awk 'BEGIN{RS="";FS="\t"} {print $4}' test.txt`。

![](https://tf-picture-bed-1259792641.cos.ap-beijing.myqcloud.com/blog/2021-09-21-151842.png)

输出的结果，就是我们想要的每一个记录的第四个域的内容了。也就是电话号码~

刚刚的代码，首先是在一开头修改的分隔符，然后`{print $4}`表示的是对每一个记录进行`print $4`的操作。这里的`$4`就是我们要说的awk的基础变量。这里的4指的就是第四个域。

**对于awk的每一个记录，其相应的第n个域会保存在`$n`这个变量中。而`$0`则是该条记录。**
>`print`后面不跟任何变量就是`print $0`。并且`print`后面会自动添加一个换行符。

这样awk一个好处出现了：可以根据分割符，把任意一个文本处理成类似excel表格的形式，我们可以任意调用`$n`也就是获取每一行（记录）中的一列（域）。

>`print`函数的用法有很多。比如：
>- `awk 'BEGIN{RS="";FS="\t"} {print $1 ,$2,$3, $4}' test.txt`

除了这样的变量之外，我们刚刚提到的`RS`，`FS`也是内置变量之一。实时上完整的内置变量有很多。可以见下表![](https://tf-picture-bed-1259792641.cos.ap-beijing.myqcloud.com/blog/2021-09-21-065223.png)

但是我们比较常用的有这样几个：

- `FS` 输入字段的分隔符
- `OFS` 输出字段的分隔符。`o`也就是output
- `RS` 输入数据的一个记录的分隔符
- `ORS` 输出数据的一个记录的分隔符
  - `{print $1,$2}`中的`,`会被自动解释成`ORS`

- `NF` **NF表示浏览的这个记录的域的个数**，是个数字。通常使用是`$NF`，也就是相当于取这个这个数字对应的变量
  - `$NF` =`$n`，这里的n就是当前记录所拥有的域的个数，也就是储存了最后一个域的变量。
- `NR`**已经处理的输入的记录数**

到这里基础变量就介绍完了

### 基础函数与if语句

`awk '{if (/^>/) {gsub(">","",$0);printf $0 "\t";getline;print $0 } }' test.fa`
这个代码中用到了这样几个 函数：

- `printf`
- `print`
- `gsub`
- `getline`

其中`print`和`printf`是使用率最多的函数。让我们先从这两个开始吧！
>`print`和`printf`的区别，`print`会在后面自动添加一个换行符；而`printf`则不会。

`print 变量` 可以把某个变量显示出来，或者显示一个字符串。可以是多个变量或者字符串的组合。
如：
`awk 'BEGIN{RS="";FS="\t"} {print $1" tel:" $4}' test.txt`
输出结果如下：
```
Riley Mullen tel:(312)555-1234
Frank Williams tel:(317)555-9876
Haley Snell tel:(313)555-4938
```
可以看到在`print`显示的后面会自动跟上一个换行符

而`printf`则不会，当然`printf`仅仅用于替代`print`是大材小用了，这个后面在说。

>more:`awk 'BEGIN{RS="";FS="\t"} {printf $1"\t" ;printf "tel:";print $4}' test.txt`

`gsub(a,b,string)`。也就是对string这个字符串，在其中寻找`a`然后用`b`替换
举个例子，我们的`test.fa`里面有5个DNA序列，名称分别是`blah_C1`等。现在想把`blah`替换成`sequence`。
那么使用`gsub`便可以了。

`awk '{gsub("blah","sequence",$0); print}' test.fa` 这里的`;`和linux命令中的`;`是一样的，表示换行的含义。

这个命令对每一个记录进行搜索找到符合pattern:`blah`的地方，并用`sequence`替换掉。 这个pattern可以是正则表达式。
>pattern，也就是一个文本模式，比如这里的`blah`。

到这里，再介绍一下if语句的简单写法，我们就可以进行一开头提到的工作啦

也很简单 `awk '{if (condition/pattern) {动作1} else {动作2} }'`。也就是`condition/pattern`成立的时候，会执行动作1，反之动作2。
>这个地方的pattern，也就是刚刚提到的pattern，这个写法呢有一点点需要注意的：`/pattern/`，需要用两个`/`来包裹住你的pattern。当然这个`pattern`可以是`re`

既然有了`if`我们就好办了。`.fa`文件的每一条序列是以`>`开头。我们只需要找到每一个`>`的记录，那么它的下一个记录就是它的序列了。并且我们找到`>`这个的记录后还可以对它进行`gsub`，来用空白替换掉`>`。说着是挺简单的。

`awk '{if (/>/) {printf $0 "\t"} else {print $0} }' test.fa`
![](https://tf-picture-bed-1259792641.cos.ap-beijing.myqcloud.com/blog/2021-09-21-155452.png)

>第一个采用`printf`，是因为不希望输出的结果后面会跟换行符，`\t`是制表符也就是`tab`；当不是`>`这个的时候，也就是下一行，自然的就是DNA序列，我们希望这个后面会有个换行符`print $0`。
现在匹配到`>`的记录里面加入`gsub`，来替换掉`>`。

`awk '{if (/>/) {gsub(">","",$0);printf $0 "\t"} else {print $0} }' test.fa`
运行一下试试吧。

这个是不是和之前写得代码有点差距呢？没有用到`getline`对吧。

`

